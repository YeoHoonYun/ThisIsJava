객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.

캡슐화 : 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것 / 외부객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
상속 : 부모가 가지고 있는 재산을 자식에게 물려주는 것 / 상위 객체를 재상용하여 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들어 줌.
다형성 : 같은 타입이지만 실행결과가 다양한 객체를 이용할 수 있는 성질

객체와 클래스
개발자 => 클래스(설계도) => 인스턴스(객체)
Student s1 = new Student();

public class ClassName {
    //필드
    int fieldName;

    //생성자
    ClassName() {}

    //메소드
    void methodName(){}
}

필드 : 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
생성자 : new 연산자와 같이 사용되어 클래스로부터 객체를 생성 할 떄 호출되어 객체의 초기화를 담당
    - 기본 생성자 : 클래스에서 하나이상 존재하는 생성자
    - 생성자 선언
    public class Car {
        Car(String color, int cc){
        }
    }

    - 필드 초기화
    public class Korean {
        String nation = "대한민국";
        String name;
        String ssn;
    }

    - 생성자 오버로딩
    public class Car {
        Car(){}
        Car(String model){}
        Car(String model, String coler){}
        Car(String model, String color, int maxSpeed){}
    }

메소드 : 객체의 동작에 해당하는 중괄호 블록
메소드 오버로딩 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것

인스턴스 멤버와 this
 - 인스턴스 멤버 : 객체를 생성한 후 사용할 수 있는 필드와 메소드
 - this : 객체 자기 자신

정적 멤버와 static
 - 정적 멤버 : 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드

싱글톤
 - 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있는데, 단 하나의 객체가 싱글톤
 public class 클래스{
    pricate static 클래스 singleton = new 클래스();

    private 클래스(){}

    static 클래스 getInstance(){
        return singleton;
    }
 }

final 필드와 상수
 - final 필드 : 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그래밍 실행 도중에 수정 할 수 없는 필드
 - 상수 : 불변의 값을 저장하는 필드(불변의 값 : 객체마다 저장할 필요가 없는 공용성을 띠고 있으며 여러가지 값으로 초기화 될 수 없기 때문)

접근 제한자
 - public : 클래스, 필드, 생성자, 메소드 / 없음
 - protected : 필드, 생성자, 메소드 / 자식 클래스가 아닌 다른 패키지에 소속된 클래스(상속이 안된)
 - default : 클래스, 필드, 생성자, 메소드 / 다른 패키지에 소속된 클래스
 - private : 필드, 생성자, 메소드 / 모든 외부 클래스

Getter / Setter 메소드
 - 일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.

@어노테이션
어노테이션 = 메타 데이터 : 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보

